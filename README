The pwtools package.

License
=======

See the files LICENSE and COPYING.

Features
========

The package was initially developed to calculate the phonon density of states
from (ab initio) MD calculations. Over time, the package evolved into a
general-purpose pre- and postprocessing tool. Current featues include:

* classes to set up calculations (parameter studies) based on template
  input files for any kind of computational backend
* simple sqlite3 interface with convenience data extraction methods 
* velocity autocorrelation function from MD trajectories
* phonon DOS from MD trajectories
* parsing of PWscf [qe]_ and CPMD [cpmd]_ output into Python objects for easy
  access
* IO: read cif, cml, pdb, write xsf, cif, xyz  
* interface to external EOS fitting tools 
* thermodynamic properties in the quasi-harmonic approximation from phonon
  density of states  
* MD analayis: radial pair distribution function (own implementation and VMD
  [10] interface), RMS, RMSD
* unit cell related tools: super cell building, coordinate transformation,
  convert back and forth between unit cell vectors and crystallographic
  constants

Related projects
----------------

The very nice ASE [ase]_ project is in some way related. It also stores MD
trajectory data in Python objects for further manipulation. It's IO
capabilities are much more developed. One can convert structure data (see
crys.Structure, crys.Trajectory) to an ASE Atoms object and use ASE's file
writers. ASE provides interfaces to a large pile of ab initio codes
("calculators"). MD and structure optimization in ASE is coded in Python, using
only the calculator's SCF engine in every step to get energy and forces.
Unfortunately, it does not  provide wave function extrapolation for
Born-Oppenheimer MD and phonon calculations based on density functional
perturbation theory like PWscf/PH or Abinit (only supercell frozen phonons can
be done with the related phonopy package [phonopy]_). The focus of the pwtools
package is to be a handy pre- and postprocessor providing pythonic access to
all input and output quantities of the used ab initio codes (PWscf,
CPMD). 

In fact, appart from parse.py, which implements parsers for ab initio code
output, all other parts of the package are completely independent.

Installation
============

Add-ons / plugins
-----------------

Some add-on tools (``PyCifRW`` and ``eos``) can be found in the "pwextern-free"
package [pwextern-free]_, see below. It is strongly suggested to install them
as well. 

There is another package with non-free (non-GPL) extra tools which are
not necessary for using pwtools (in-house use only: ``fourier`` from CPMD and
``sgroup`` from Wien2k). 

pwtools install
---------------

There is no installation script (i.e. setup.py). Just copy the whole package
somewhere and run ``make`` to compile extensions::

    $ tar -xzf pwtools-x.y.z.tgz
    $ mv pwtools-x.y.z $HOME/python/pwtools
    $ cd $HOME/python/pwtools
    $ make

Path issues (.bashrc/.profile)
------------------------------

Suppose all files are in $HOME/python/pwtools/::
    
    # makes "import pwtools" possible
    export PYTHONPATH=$PYTHONPATH:$HOME/python
    # If you like, make cmd line tools available.    
    export PATH=$HOME/python/pwtools/bin:$PATH

Note that the basename of the dir *must* be named "pwtools" b/c it's the
package's root dir.

Fortran extension
-----------------

Some time-critical operations are coded using a Fortran extension module
(flib.f90, _flib.so, Makefile). You need to build that in order for all tests
to pass.

Running tests
-------------

See tests/README. Actually, all of these are good examples, too!

Python versions
---------------

Developed mostly with Python 2.5/2.6. Should work with all versions from 2.4
on, but not yet 3.x. 

With Python 2.6, you may get a DeprecationWarning regarding the sets module
when the CifFile module from the pycifrw package is imported (unless you
install the patched version from [pwextern-free]_.

Add-on packages / other required tools
--------------------------------------

Must have:    

* numpy
* scipy
* nose (for running tests in test/)
* python headers (development files for compiling Fortran extension)  
* Unix tools: grep, sed, awk, tail, wc (for parse.py); gzip/gunzip (for
  ``test/``)

Debian: ``aptitude install python-numpy python-scipy python-nose python-dev``

Almost must have:
  
* BeautifulSoup [beautifulsoup]_: XML parser (for .cml files)
  Debian: ``aptitude install python-beautifulsoup``.
* PyCifRW [pycifrw_orig]_: For Cif files. If you use the version from
  [pwextern-free]_, then you even get an install script :)
* eos (for ``eos.py``): The tool "eos" from the Elk code [elk]_ must be on your
  path. Note that the executable is assumed to be named "eos.x". See
  ``pwtools.eos.ElkEOSFit`` for usage. Can be installed directly from Elk or
  also [pwextern-free]_.
* h5py: ``aptitude install python-h5py``

Without BeautifulSoup and PyCifRW, you will get import warnings, some parsing
classes and IO functions will not work (Cif and CML parsing currently) and some
tests will fail. If you don't need that functionality, uncomment the warnings
and import statements at the top of ``parse.py`` and ``io.py``.
Without ``eos``, ``pwtools.eos.ElkEOSFit`` and related tests won't work.

Suggested:

* matplotlib (``examples/``), ``aptitude install python-matplotlib``
* VMD [vmd]_ (``examples/rpdf/``), must register before download

Optional:

* The "fourier.x" tool from the CPMD [cpmd]_ contrib sources (for
  ``examples/``). Need to register before download.

Usage
=====

See ``test/test_*.py`` and ``examples/`` for examples.

Velocity autocorrelation function and phonon DOS
------------------------------------------------

There are two ways of computing the phonon density of states (PDOS) from 
an MD trajectory (V is is array of atomic velocities, see pydos.velocity(). 

(1) vacf way: FFT of the velocity autocorrelation function (vacf):
    V -> VACF -> FFT(VACF) = PDOS, see pydos.vacf_pdos()
(2) direct way: ``|FFT(V)**2|`` = PDOS, see pydos.direct_pdos(), this is much
    faster and mathematically exactly the same, see examples/pdos_methods.py
    and test/test_pdos.py .

Both methods are implemented but actually only method (2) is worth using.
Method (1) still exists for historical reasons and as reference.

* In method (1), if you mirror the VACF at t=0 before the FFT, then you get
  double frequency resolution. 

* By default, direct_pdos() uses zero padding to get the same frequency
  resolution as you would get with mirroring the signal in vacf_pdos().

* Both methods use Welch windowing by default to reduce "leakage" from
  neighboring peaks. See also examples/pdos_methods.py 

* Both methods must produce exactly the same results (up to numerical noise).

* The frequency axis of the PDOS is in Hz. It is "f", NOT the angular frequency 
  2*pi*f. See also examples/pdos_methods.py .


Units of parsed quantities
==========================

We have a lot of machinery to parse PWscf and CPMD output files. We try to
return the "natural" units of each code (PWscf: Ry, Bohr, kbar; CPMD: Ha, Bohr,
kbar). For PWscf, we also detect things like "ATOMIC_POSITIONS crystal | alat |
bohr" and transform accordingly. Nevertheless, *always* verify that the units
you get are the ones you expect!

You can also use the short-cut methods io.read*(), which will return
crys.Structure or crys.Trajectory with units eV, Angstrom, ...

Format-specific notes
=====================

Pwscf
=====

Units
-----

From http://www.quantum-espresso.org/input-syntax/INPUT_PW.html:
"All quantities whose dimensions are not explicitly specified are in
RYDBERG ATOMIC UNITS". See also ``constants.py``.

matdyn.x and phonon dos: 
    With dos=.true., matdyn.x calculates the phonon density of states. The
    frequency axis in the output file is f in cm^-1. Note that THIS IS NOT THE
    ANGULAR FREQUENCY omega = 2*pi*f!!! Therefore, if you calculate with this
    frequency as in "hbar*omega", then use f*2*pi!

Atomic coordinates
------------------

In PWscf terms, alat = celldm(1) = lattice constant "a" in a.u. . A length in
a.u. means a unit or Bohr = a0 = 0.52917720859 Angstrom.

To calculate the PDOS, atomic coordinates from MD trajectories have to be in
cartesian coordinates. You may have to transform them *before* using them to
calculate the PDOS. See

``test/test_pdos.py``
``test/test_pdos_coord_trans.py``

This is necessary if you have "ATOMIC_POSITIONS crystal".

The scale (or unit: Bohr, Angstrom, ..., defined by celldm(1) or
CELL_PARAMETERS) does not matter, b/c currently the integral area under the
PDOS curve is normalized in pydos.*_pdos(). But coords MUST be cartesian!

For your convenience, here is a list of all possible formats (from the Pwscf
help)::

    allowed ATOMIC_POSITIONS units:
       alat    : atomic positions are in cartesian coordinates,
                 in units of the lattice parameter "a" (default)

       bohr    : atomic positions are in cartesian coordinate,
                 in atomic units (i.e. Bohr)

       angstrom: atomic positions are in cartesian coordinates,
                 in Angstrom

       crystal : atomic positions are in crystal coordinates, i.e.
                 in relative coordinates of the primitive lattice vectors

Note: crystal coords are also called fractional coordinates (e.g. in Cif
files).

summary::

    ATOMIC_POSITIONS angstrom  -> cartesian angstrom
    ATOMIC_POSITIONS bohr      -> cartesian a.u. 
    ATOMIC_POSITIONS           -> cartesian alat
    ATOMIC_POSITIONS alat      -> cartesian alat
    ATOMIC_POSITIONS crystal   -> crystal alat or crystal a.u. (see below)

The unit of CELL_PARAMETERS is only important for ATOMIC_POSITIONS crystal::

    if celldm(1) present  -> CELL_PARAMETERS in alat -> crystal alat
        => CELL_PARAMETERS = real cell parameter divided by alat
    if not                -> CELL_PARAMETERS in a.u. -> crystal a.u.
        => CELL_PARAMETERS are in Rydberg atomic units, i.e. in Bohr.

Total force on atoms
--------------------

Pwscf writes a "Total Force" after the "Forces acting on atoms" section . This
value is kind of an RMS of the force matrix (f_ij, i=1,natoms j=1,2,3) printed.
According to .../PW/forces.f90, variable "sumfor", the "Total Force" is::

    sqrt(sum_ij f_ij^2)

But this is not normalized to the number of atoms. Use crys.rms() or
crys.rms3d() for MD runs where the RMS of each (f_ij) is::

    sqrt( (sum_ij f_ij^2) / N )

with N = 3*natoms or N=natoms.   

References
----------

.. [qe] http://www.quantum-espresso.org
.. [ase] https://wiki.fysik.dtu.dk/ase
.. [mttk] Glenn J. Martyna and Mark E. Tuckerman and Douglas J. Tobias and Michael
    L. Klein, "Explicit reversible integrators for extended systems
    dynamics", Mol. Phys. 87(5), pp. 1117, 1996
.. [phonopy] http://phonopy.sourceforge.net
.. [pycifrw_orig] http://pycifrw.berlios.de
.. [pwextern-free] https://bitbucket.org/elcorto/pwextern-free
.. [beautifulsoup] http://www.crummy.com/software/BeautifulSoup
.. [elk] http://elk.sourceforge.net
.. [cpmd] http://www.cpmd.org
.. [vmd] http://www.ks.uiuc.edu/Research/vmd/

.. vim:comments=fb\:*:syn=rst
