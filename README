The pwtools package.

=======
License
=======

See the files LICENSE and COPYING.

========
Features
========

The package was initially developed to calculate the phonon density of states
from (ab initio) MD calculations. Over time, the package evolved into a
general-purpose pre- and postprocessing tool. Current featues include:

- classes to set up calculations (parameter studies) based on template
  input files
- simple sqlite3 interface with convenience data extraction methods 
- velocity autocorrelation function from MD trajectories
- phonon DOS from MD trajectories
- parsing of PWscf [1] input and output files and Abinit [3] output into Python
  objects for easy access
- IO: read cif, cml, pdb, write xsf, cif, xyz  
- interface to external EOS fitting tools 
- thermodynamic properties in the quasi-harmonic approximation from phonon
  density of states  
- MD analayis: radial pair distribution function (own implementation and VMD
  interface), RMS, RMSD
- unit cell related tools: super cell building, coordinate transformation,
  convert back and forth between unit cell vectors and crystallographic
  constants

Related projects
----------------

The very nice ASE [2] project is in some way related. It also stores MD
trajectory data in Python objects for further manipulation. It's IO
capabilities are much more developed. One can convert structure data to an ASE
Atoms object and use ASE's file writers (see structure.py and
examples/ase_atoms.py). ASE provides interfaces to a large pile of ab initio
codes ("calculators"). MD and structure optimization in ASE is coded in Python,
using only the calculator's SCF engine in every step to get energy and forces.
Unfortunately, it does not jet provide things like variable cell MD with the
MTTK [4] method and phonon calculations based on density functional
perturbation theory like PWscf/PH or Abinit (only supercell frozen phonons).
The focus of the pwtools package is to be a handy pre- and postprocessor
providing pythonic access to all input and output quantities of the used ab
initio codes (PWscf, Abinit). 

============
Installation
============

There is no installation script. Just copy the whole package somewhere, e.g.
    $ tar -xzf pwtools-0.7.3.tgz
    $ mv pwtools-0.7.3 $HOME/python/pwtools

Path issues (.bashrc/.profile)
------------------------------

Suppose all files are in $HOME/python/pwtools/.
    
    # makes "import pwtools" possible
    export PYTHONPATH=$PYTHONPATH:$HOME/python
    # If you like, make cmd line tools available.    
    export PATH=$HOME/python/pwtools/bin:$PATH

Note that the basename of the dir *must* be named "pwtools" b/c it's the
package's root dir.


Fortran extensions
------------------

To calculate the velocity autocorrelation function (and to pass all tests), you
want to use a Fortran extension module. See Makefile. Note that this is not
necessary for the "Direct Method" (see below).

Running tests
-------------

See tests/README. Actually, all of these are good examples, too!

Python versions
---------------

Developed mostly with Python 2.5/2.6. Should work with all versions from 2.4
on, but not yet 3.x. 

With Python 2.6, you may get a DeprecationWarning regarding the sets module
when the CifFile module from the pycifrw package is imported.

Add-on packages / other required tools
--------------------------------------

Must have:
    - numpy 
    - scipy
    - nose (for running tests in test/)  
    On Debian-based distros, "aptitude install python-numpy python-scipy
    python-nose" should do it.
    - Unix tools: grep, sed, awk, tail, wc (for parse.py); gzip/gunzip (for
      test/*)

optional: 
    parse.py:
        - PyCifRW (http://pycifrw.berlios.de)
        - BeautifulSoup (http://www.crummy.com/software/BeautifulSoup/)
        
        Without these, you will get warnings and some parsing classes and IO
        functions will not work (Cif and CML parsing currently). If you wish,
        uncomment the warnings at the top of parse.py .
    examples/*, mpl.py
        - matplotlib

=====
Usage
=====

See test/test_*.py and examples/ for examples.

Methology
---------

There are two ways of computing the phonon density of states (PDOS) from 
an MD trajectory (V is is array of atomic velocities, see pydos.velocity(). 

(1) vacf way: FFT of the velocity autocorrelation function (vacf):
    V -> VACF -> FFT(VACF) = PDOS, see pydos.vacf_pdos()
(2) direct way: |FFT(V)**2| = PDOS, see pydos.direct_pdos(), this is much
    faster and mathematically exactly the same, see examples/pdos_methods.py
    and test/test_pdos.py .

Both methods are implemented but actually only method (2) is worth using.
Method (1) still exists for historical reasons and as reference.

- In method (1), if you mirror the VACF at t=0 before the FFT, then you get
  double frequency resolution. 

- By default, direct_pdos() uses zero padding to get the same frequency
  resolution as you would get with mirroring the signal in vacf_pdos().

- Both methods use Welch windowing by default to reduce "leakage" from
  neighboring peaks. See also examples/pdos_methods.py 

- Both methods must produce exactly the same results (up to numerical noise).

- The frequency axis of the PDOS is in Hz. It is "f", NOT the angular frequency 
  2*pi*f. See also examples/pdos_methods.py .


=====================
Format-specific notes
=====================

Pwscf
=====

Units
-----

From http://www.quantum-espresso.org/input-syntax/INPUT_PW.html
    All quantities whose dimensions are not explicitly specified are in
    RYDBERG ATOMIC UNITS
See constants.py

matdyn.x and phonon dos: With dos=.true., matdyn.x calculates the phonon
    density of states. The frequency axis in the output file is f in cm^-1.
    Note that THIS IS NOT THE ANGULAR FREQUENCY omega = 2*pi*f!!! Therefore, if
    you calculate with this frequency as in "hbar*omega", then use f*2*pi!

Atomic coordinates
------------------

In PWscf terms, alat = celldm(1) = lattice constant "a" in a.u. . A length in
a.u. means a unit or Bohr = a0 = 0.52917720859 Angstrom.

To calculate the PDOS, atomic coordinates from MD trajectories have to be in
cartesian coordinates. You may have to transform them *before* using them to
calculate the PDOS. See 
    test/test_pdos.py 
    test/test_pdos_coord_trans.py

This is necessary if you have "ATOMIC_POSITIONS crystal".

The scale (or unit: Bohr, Angstrom, ..., defined by celldm(1) or
CELL_PARAMETERS) does not matter, b/c currently the integral area under the
PDOS curve is normalized in pydos.*_pdos(). But coords MUST be cartesian!

For your convenience, here is a list of all possible formats:

allowed ATOMIC_POSITIONS units (from the Pwscf help):
   alat    : atomic positions are in cartesian coordinates,
             in units of the lattice parameter "a" (default)

   bohr    : atomic positions are in cartesian coordinate,
             in atomic units (i.e. Bohr)

   angstrom: atomic positions are in cartesian coordinates,
             in Angstrom

   crystal : atomic positions are in crystal coordinates, i.e.
             in relative coordinates of the primitive lattice vectors

Note: crystal coords are also called fractional coordinates (e.g. in Cif
files).

summary:

    ATOMIC_POSITIONS angstrom  -> cartesian angstrom
    ATOMIC_POSITIONS bohr      -> cartesian a.u. 
    ATOMIC_POSITIONS           -> cartesian alat
    ATOMIC_POSITIONS alat      -> cartesian alat
    ATOMIC_POSITIONS crystal   -> crystal alat or crystal a.u. (see below)

The unit of CELL_PARAMETERS is only important for ATOMIC_POSITIONS crystal:
    if celldm(1) present  -> CELL_PARAMETERS in alat -> crystal alat
        => CELL_PARAMETERS = real cell parameter divided by alat
    if not                -> CELL_PARAMETERS in a.u. -> crystal a.u.
        => CELL_PARAMETERS are in Rydberg atomic units, i.e. in Bohr.

Total force on atoms
--------------------

Pwscf writes a "Total Force" after the "Forces acting on atoms" section . This
value is kind of an RMS of the force matrix (f_ij, i=1,natoms j=1,2,3) printed.
According to .../PW/forces.f90, variable "sumfor", the "Total Force" is
    sqrt(sum_ij f_ij^2)
But this is not normalized to the number of atoms. Use crys.rms() or
crys.rms3d() for MD runs where the RMS of each (f_ij) is 
    sqrt( (sum_ij f_ij^2) / N )
with N = 3*natoms or N=natoms.   


Parsed results
--------------

Concerns: parse.Pw*File, parse.Abinit*File

Abinit : Here, all relevant quantities are printed in the output files alone
    with enough precision to do further calculations inside these classes (not
    used yet).
PWscf : Sadly, things like cell information (CELL_PARAMETERS) and kpoint grid
    (K_POINTS) are only printed with low precision or not at all in the output
    file. ATM, we parse input and output separately (in recent versions). So,
    calculations based on higher-precision quantities in the input file are not
    automatically done in Pw*File. 

====
Refs
====

[1] http://www.quantum-espresso.org
[2] https://wiki.fysik.dtu.dk/ase
[3] http://www.abinit.org
[4] Glenn J. Martyna and Mark E. Tuckerman and Douglas J. Tobias and Michael
    L. Klein, "Explicit reversible integrators for extended systems
    dynamics", Mol. Phys. 87(5), pp. 1117, 1996

