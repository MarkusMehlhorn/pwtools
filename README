The pwtools package.

Copyright (c) 2008-2010, Steve Schmerler <mefx@gmx.net>.

============
Installation
============

There is no installation script. Just copy the whole package somewhere, e.g.
    $ tar -xzf pwtools-0.7.3.tgz
    $ mv pwtools-0.7.3 $HOME/python/pwtools

path issues (.bashrc/.profile)
------------------------------

Suppose all pwtools files are in $HOME/python/pwtools/.
    
    # makes "import pwtools" possible
    export PYTHONPATH=$PYTHONPATH:$HOME/python

If you like, make cmd line tools available.    
    export PATH=$HOME/python/pwtools/bin:$PATH

Fortran extensions
------------------

To calculate the velocity autocorrelation function, you want to use a Fortran
extension module. See Makefile. Note that this is not necessary for the "Direct
Method" (see below).

Python versions
---------------

Developed mostly with Python 2.5. Should work with all versions from 2.4 on,
bot not yet 3.x. Also, python2.6 has not jet been tested.

Add-on packages
---------------

Must have:
    - numpy 
    - scipy
    On Debian-based distros, "aptitude install python-numpy python-scipy"
    should do it.

optional: 
    parse.py:
        - PyCifRW (http://pycifrw.berlios.de)
        - BeautifulSoup (http://www.crummy.com/software/BeautifulSoup/)
        
        Without these, you will get warnings and some parsing classes will not
        work (Cif and CML parsing currently). If you wish, uncomment the warnings
        at the top of parse.py .
    test/*
        - matplotlib

=====
Usage
=====

See test/test_*.py and examples/ for examples.

Methology
---------

There are two ways of computing the PDOS (V is is array of atomic velocities,
see pydos.velocity(). 

(1) vacf way: FFT of the velocity autocorrelation function (vacf):
    V -> VACF -> FFT(VACF) = PDOS, see pydos.vacf_pdos()
(2) direct way: |FFT(V)**2| = PDOS, see pydos.direct_pdos(), this is much
    faster and mathematically exactly the same, see test/test_pdos_methods.py

- In method (1), if you mirror the VACF before the FFT, then you get double
  frequency resolution. 

- By default, direct_pdos() uses zero padding to get the same frequency
  resolution as you would get with mirroring the signal in vacf_pdos().

- Both methods use Welch windowing by default to reduce "leakage" from
  neighboring peaks. See also test/test_pdos_methods.py 

- Both methods must produce exactly the same results (up to numerical noise).

- The frequency axis of the PDOS is in Hz. It is "f", NOT the angular frequency 
  2*pi*f. See also test/test_pdos_methods.py .


=====================
Format-specific notes
=====================

Pwscf
=====

Units
-----

From http://www.quantum-espresso.org/input-syntax/INPUT_PW.html
    All quantities whose dimensions are not explicitly specified are in
    RYDBERG ATOMIC UNITS
See constants.py

matdyn.x and phonon dos: With dos=.true., matdyn.x calculates the phonon
    density of states. The frequency axis in the output file is f in cm^-1.
    Note that THIS IS NOT THE ANGULAR FREQUENCY omega = 2*pi*f!!! Therefore, if
    you calculate with this frequency as in "hbar*omega", then use f*2*pi!

Atomic coordinates
------------------

To calculate the PDOS, atomic coordinates from MD trajectories have to be in
cartesian coordinates. You may have to transform them *before* using them to
calculate the PDOS. See 
    test/test_pdos.py 
    test/test_pdos_coord_trans.py

This is necessary if you have 
    ATOMIC_POSITIONS crystal

The scale (or unit: Bohr, Angstrom, ..., defined by celldm(1) or
CELL_PARAMETERS) does not matter, b/c currently the integral area under the
PDOS curve is normalized in pydos.*_pdos(). But coords MUST be cartesian!

For your convenience, here is a list of all possible formats:

allowed ATOMIC_POSITIONS units (from the Pwscf help):
   alat    : atomic positions are in cartesian coordinates,
             in units of the lattice parameter "a" (default)

   bohr    : atomic positions are in cartesian coordinate,
             in atomic units (i.e. Bohr)

   angstrom: atomic positions are in cartesian coordinates,
             in Angstrom

   crystal : atomic positions are in crystal coordinates, i.e.
             in relative coordinates of the primitive lattice vectors

Note: crystal coords are also called fractional coordinates (e.g. in Cif files).

summary:

    ATOMIC_POSITIONS angstrom  -> cartesian angstrom
    ATOMIC_POSITIONS bohr      -> cartesian bohr  [== a.u.] 
    ATOMIC_POSITIONS           -> cartesian alat
    ATOMIC_POSITIONS alat      -> cartesian alat
    ATOMIC_POSITIONS crystal   -> crystal alat or crystal a.u. 

The unit of CELL_PARAMETERS is only important for ATOMIC_POSITIONS crystal,
i.e. if one wants to calculate cartesian coords. Note that alat == celldm(1).
    if celldm(1) present  -> CELL_PARAMETERS in alat -> crystal alat
        => CELL_PARAMETERS = real cell parameter divided by alat
    if not                -> CELL_PARAMETERS in a.u. -> crystal a.u.
        => CELL_PARAMETERS are in Rydberg atomic units, i.e. in Bohr.

Total force on atoms
--------------------

Pwscf writes a "Total Force" after the "Forces acting on atoms" section . This
value is kind of an RMS of the force matrix (f_ij, i=1,natoms j=1,2,3) printed.
According to .../PW/forces.f90, variable "sumfor", the "Total Force" is
    sqrt(sum_ij f_ij^2)
But this is not normalized to the number of atoms. Use crys.rms() or
crys.rms3d() for MD runs where the RMS of each (f_ij) is 
    sqrt( (sum_ij f_ij^2) / N )
with N = 3*natoms or N=natoms.   
