pydos.py
--------
* unify vacf_pdos(), direct_pdos(), they have almost the same signature and
  functionality, use a kwarg 'method' to select the method of calculation

* PDOS normalization. ATM we normalize so that Int(faxis, pdos) = area = 1.0. 
  But there may be others, like area = 3*natoms in the unit cell (not
  supercell), ...

all
---
* Drop verbose.py. Use the logging or warnings module.

* io.write_*(): by using `cryst_const` instead of `cell`, we would get rid of
  the annoying `align` kwarg. In fact, I think it is really used only
  crys.coord_trans().

ase interface and some ideas on how to not use plain 3d arrays
--------------------------------------------------------------

* It is probably bad design to use cell, coords, symbols, etc as separate
  objects. Use ase.Atoms as the central container to hold one unit cell, or
  finish structure.Structure, which has essentially the same goal. Make all
  functions in crys.py etc use this as input instead of coords/cell/symbols.
  The only really cool thing about ase.Atoms is that __imul__ creates a
  supercell. Besides that, we have the same functionality already present in
  pwtools, but split across several modules (parse, crys, etc). We don't need
  the calculator stuff at all, b/c we do calculations based on template files
  etc (batch.py), not inside Python scripts on the cluster.

* Implement trajectories as list-like objects which represent a sequence of
  Atoms. That's all. For details, see below. 
  XXX Possible problem: b/c of the grep approach to parsing trajectories, we
  cannot guarantee that all 3d arrays have the same length along the time axis!

* Get rid of parse.py's CifFile, PDBFile, CMLFile etc. Use ase.io.read() or
  io.read_* and return Atoms. 
 
* Keep PwInputFile for historical reasons, add get_atoms() method which returns
  Atoms if possible.

* Using raw 3d arrays for trajectories is cumbersome, esp. when we want to do
  coord transformations (see io.write_axsf()). Update: We have a new
  crys.coord_trans() version, which is more usable.

  Add unified storage class Trajectory (like structure.Structure) to hide the
  data storage as 3d arrays. Make them have list-like behavior (modify
  __getitem__), much like ASE's PickleTrajectory.
      >>> traj = Trajectory(...)
      >>> assert (traj[0] == traj.raw_coords[...,0]).all()
  Or only implement a Trajectory class to hold 3d arrays, which hides the
  time_axis stuff.

* ase.Atoms is nice, but for some reason, it has no set_forces() (or some such)
  method. Last time I checked, forces are retrieved from the attached
  Calculator object, but cannot be set freely, which is pretty sad for a
  container class. Subclass ase.Atoms -> PwAtoms, add set_forces() method. In
  StructureFileParser, add method get_ase_atoms() which adds forces and returns
  a PwAtoms instance. ATM, we have that, but w/o forces.

* Check if a ASE trajectory (do they just have this PickleTrajectory thing?) is
  just a list of Atoms objects or if PickleTrajectory instances have a list API
  while storing coords, cell etc more efficiently (like PwOutputFile as 3d
  arrays :). Then, add get_ase_traj() to PwOutputFile etc.

* io.write_*: make coords = cartesian and skip the coord trans which is
  currently forced, add input arg coords_frac for fractional, do coord trans
  only here

tests
-----
* Handle known fails with nose.

abinit.AbinitInput
------------------
* Rename or incorporate into structure.Structure, as this stuff is also useful
  for other input files.

plotting dispersions
--------------------
* Finish functions for parsing and plotting dispersions (pwscf.py, kpath.py).
  Remove unused and redundant stuff.

# vim:comments=fb\:*
